1. Bubble Sort
Time Complexity: O(n^2) (Best: O(n) if nearly sorted)
Space Complexity: O(1)
Note: Stable sort, suitable for small or nearly sorted datasets.

2. Selection Sort
Time Complexity: O(n^2)
Space Complexity: O(1)
Note: Unstable; always does n*(n-1)/2 comparisons regardless of input order.

3. Insertion Sort
Time Complexity: O(n^2) (Best: O(n) if nearly sorted)
Space Complexity: O(1)
Note: Stable; very efficient for small or nearly sorted arrays.

4. Shell Sort
Time Complexity: ~O(n^3/2) using halving gaps (depends on gap sequence)
Space Complexity: O(1)
Note: Not stable; complexity varies with chosen gap sequence.

5. Merge Sort
Time Complexity: O(n log n)
Space Complexity: O(n)
Note: Stable sort; excellent for linked lists and external sorting.

6. Quick Sort
Time Complexity: Average O(n log n), Worst O(n^2)
Space Complexity: O(log n) recursion (avg), O(n) recursion (worst)
Note: Unstable; often fastest in practice; randomized pivot helps avoid worst case.

7. Bucket Sort
Time Complexity: O(n + k), where k = number of buckets + cost of sorting each bucket
Space Complexity: O(n + k)
Note: Best suited for uniformly distributed data in [0,1). Stable if bucket sort subroutine is stable.

8. Counting Sort
Time Complexity: O(n + k), where k = max element + 1
Space Complexity: O(n + k)
Note: Stable; works only for integers with limited range.

9. Radix Sort
Time Complexity: O(d * (n + b)), where d = number of digits, b = base (10 here)
Space Complexity: O(n + b)
Note: Stable; requires stable subroutine like Counting Sort.

10. Heap Sort
Time Complexity: O(n log n)
Space Complexity: O(1)
Note: Unstable; in-place sorting algorithm, good for memory-constrained systems.